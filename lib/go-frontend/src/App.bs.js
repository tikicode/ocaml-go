// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as JsxRuntime from "react/jsx-runtime";

import './App.css'
;

function findOffset(x, y, left, right, top, bottom, squareSize) {
  if (x >= (left - 1 | 0) && x <= ((right + 1 | 0) - (squareSize / 2 | 0) | 0) && y >= (top - 1 | 0) && y <= ((bottom + 1 | 0) - (squareSize / 2 | 0) | 0)) {
    return [
            -10.0,
            -10.0
          ];
  } else if (x >= (left - 1 | 0) && x <= ((right + 1 | 0) - (squareSize / 2 | 0) | 0) && y >= ((top - 1 | 0) + (squareSize / 2 | 0) | 0) && y <= (bottom + 1 | 0)) {
    return [
            -10.0,
            15.5
          ];
  } else if (x >= ((left - 1 | 0) + (squareSize / 2 | 0) | 0) && x <= (right + 1 | 0) && y >= (top - 1 | 0) && y <= ((bottom + 1 | 0) - (squareSize / 2 | 0) | 0)) {
    return [
            15.5,
            -10.0
          ];
  } else if (x >= ((left - 1 | 0) + (squareSize / 2 | 0) | 0) && x <= (right + 1 | 0) && y >= ((top - 1 | 0) + (squareSize / 2 | 0) | 0) && y <= (bottom + 1 | 0)) {
    return [
            15.5,
            15.5
          ];
  } else {
    return [0.0];
  }
}

function makeGrid(rows, cols) {
  var rowArray = Belt_List.makeBy(rows, (function (i) {
          return i;
        }));
  var colArray = Belt_List.makeBy(cols, (function (i) {
          return i;
        }));
  return Belt_List.toArray(Belt_List.flatten(Belt_List.map(rowArray, (function (row) {
                        return Belt_List.map(colArray, (function (col) {
                                      var handleClick = function ($$event) {
                                        var mouseX = $$event.clientX;
                                        var mouseY = $$event.clientY;
                                        var partialFunCoordinates = (function(event, mouseX, mouseY, squareSize, findOffset, row, col) {
      let true_row = Math.abs(mouseY - event.target.getBoundingClientRect().top) < Math.abs(mouseY - event.target.getBoundingClientRect().bottom) ? row : row+1;
      let true_col = Math.abs(mouseX - event.target.getBoundingClientRect().left) < Math.abs(mouseX - event.target.getBoundingClientRect().right) ? col : col+1;
      var coordinates = true_row + " " + true_col;

      function createPiece(toPlay) {
        var target = event.target;
        var offset = findOffset(mouseX, mouseY, target.getBoundingClientRect().left, target.getBoundingClientRect().right, target.getBoundingClientRect().top, target.getBoundingClientRect().bottom, squareSize);
        var divAlreadyExists = document.querySelector('[data-coordinates="' + coordinates + '"]');
          var newDiv = document.createElement("div");
          // Apply styles to pieces
          newDiv.setAttribute("data-coordinates", coordinates);
          console.log(true_row + " " + true_col);
          newDiv.style.position = "absolute";
          newDiv.style.width = "20px";
          newDiv.style.height = "20px";
          newDiv.style.borderRadius = "50%";
          newDiv.style.overflow = "hidden";
          newDiv.style.left = target.getBoundingClientRect().left + offset[0] + "px";
          newDiv.style.top = target.getBoundingClientRect().top + offset[1] + "px";
          newDiv.style.background = toPlay;

          // Append the div to the document body
          document.body.appendChild(newDiv);
        

        return [target.getBoundingClientRect().left, target.getBoundingClientRect().right , target.getBoundingClientRect().bottom , target.getBoundingClientRect().top ];
      }

      var alreadyExists = document.querySelector('[data-coordinates="' + coordinates + '"]');
      if(!alreadyExists) {
        let turnEndpoint = "http://localhost:8080/player_turn";
        getTurn(turnEndpoint)
        .then(_ => {
            let moveEndpoint = "http://localhost:8080/move";
            return makeMove(moveEndpoint);
          });
      }

      function removePiece(coordinates) {
        var divToRemove = document.querySelector('[data-coordinates="' + coordinates + '"]');
        if (divToRemove) {
          divToRemove.remove();
        }
      }

      async function makeMove(moveEndpoint) {
        console.log("Made Move");
        const response = await fetch(moveEndpoint, {
          method: "POST", 
          cache: "no-cache",
          body: (true_row+1) + " " + (true_col+1), 
        });
        const removePieces = await response.json();
        console.log(removePieces);

        for (let i = 0; i < removePieces.length; i++) {
          let pair = removePieces[i];
          let firstElem = pair[0];
          let secondElem = pair[1];
          let to_remove = firstElem + " " + secondElem;
          removePiece(to_remove);
        }
      }

      async function getTurn(turnEndpoint) {
        const response = await fetch(turnEndpoint, {
          method: "GET", 
          cache: "no-cache",
        });
        const toPlay = await response.json();
        let playerTurn = (toPlay === "White") ? "white" : "black";
        createPiece(playerTurn);
      }
      
      async function resetGame(resetEndpoint) {
        const response = await fetch(turnEndpoint, {
          method: "GET", 
          cache: "no-cache",
        });
        const reset = await response.json();
      }
    });
                                        var boundingBox = partialFunCoordinates($$event, mouseX, mouseY, 26.203125, findOffset, row, col);
                                        console.log(boundingBox);
                                      };
                                      return JsxRuntime.jsx("div", {
                                                  className: "intersection",
                                                  onClick: handleClick
                                                }, String(Math.imul(row, cols) + col | 0));
                                    }));
                      }))));
}

let resetEndpoint = "http://localhost:8080/reset_game";

  window.addEventListener('unload', async function (event) {
      console.log("RESET!");
      try {
          await fetch(resetEndpoint, {method: 'GET',});
      } catch (error) {
          console.error("Error resetting the game:", error);
      }
  });

  // var button = document.getElementById('score-button');

  // button.addEventListener('click', function() {
  //   getScore(scoreEndpoint);
  // });

  let scoreEndpoint = "http://localhost:8080/get_score";

  document.addEventListener('keydown', function(event) {
    // Type E to end the game and see the score
    if (event.key === 'E') {
      getScore(scoreEndpoint);
    } 
    // Type A to play against out AI
    else if(event.key === 'A') {
      alert("AI");
    } 
    // Type T to play a two player game
    else if(event.key === 'T') {
      alert("TwoPlayer");
    }
  });

  async function getScore(scoreEndpoint) {
    const response = await fetch(scoreEndpoint, {
      method: "GET", 
      cache: "no-cache",
    });
    const score = await response.json();

    // Remove all pieces on board
    var allPieces = document.querySelectorAll('div[data-coordinates]');

    allPieces.forEach(function(div) {
      div.remove();
    });
    
    const whiteScore = score[0];
    const blackScore = score[1];
    
    // Remove grid lines from the board
    const goBoardElement = document.querySelector('.go-board');
    goBoardElement.style.gridTemplateColumns = 'repeat(19, 1fr)';
    goBoardElement.style.gridTemplateRows = 'repeat(19, 1fr)';

    const intersections = goBoardElement.querySelectorAll('.intersection');
    intersections.forEach(intersection => {
      intersection.style.border = 'none';
    });
    
    // Display scores for white and black 
    const winnerDisplayElement = document.getElementById('winner-display');
    winnerDisplayElement.innerHTML = whiteScore > blackScore ? "White Wins!" : "Black Wins!";
    const scoreDisplayElement = document.getElementById('score-display');
    scoreDisplayElement.innerHTML = whiteScore + ' - ' + blackScore;
  }
;

function App(props) {
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx("div", {
                    children: makeGrid(19, 19),
                    className: "go-board"
                  }),
              className: "container"
            });
}

var make = App;

export {
  make ,
}
/*  Not a pure module */
