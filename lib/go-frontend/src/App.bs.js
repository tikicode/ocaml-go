// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as JsxRuntime from "react/jsx-runtime";

import './App.css'
;

function findOffset(x, y, left, right, top, bottom, squareSize) {
  if (x >= (left - 1 | 0) && x <= ((right + 1 | 0) - (squareSize / 2 | 0) | 0) && y >= (top - 1 | 0) && y <= ((bottom + 1 | 0) - (squareSize / 2 | 0) | 0)) {
    return [
            -10.0,
            -10.0
          ];
  } else if (x >= (left - 1 | 0) && x <= ((right + 1 | 0) - (squareSize / 2 | 0) | 0) && y >= ((top - 1 | 0) + (squareSize / 2 | 0) | 0) && y <= (bottom + 1 | 0)) {
    return [
            -10.0,
            15.5
          ];
  } else if (x >= ((left - 1 | 0) + (squareSize / 2 | 0) | 0) && x <= (right + 1 | 0) && y >= (top - 1 | 0) && y <= ((bottom + 1 | 0) - (squareSize / 2 | 0) | 0)) {
    return [
            15.5,
            -10.0
          ];
  } else if (x >= ((left - 1 | 0) + (squareSize / 2 | 0) | 0) && x <= (right + 1 | 0) && y >= ((top - 1 | 0) + (squareSize / 2 | 0) | 0) && y <= (bottom + 1 | 0)) {
    return [
            15.5,
            15.5
          ];
  } else {
    return [0.0];
  }
}

function makeGrid(rows, cols) {
  var rowArray = Belt_List.makeBy(rows, (function (i) {
          return i;
        }));
  var colArray = Belt_List.makeBy(cols, (function (i) {
          return i;
        }));
  return Belt_List.toArray(Belt_List.flatten(Belt_List.map(rowArray, (function (row) {
                        return Belt_List.map(colArray, (function (col) {
                                      var handleClick = function ($$event) {
                                        var mouseX = $$event.clientX;
                                        var mouseY = $$event.clientY;
                                        var partialFunCoordinates = (function(event, mouseX, mouseY, squareSize, findOffset, row, col) {
      let true_row = Math.abs(mouseY - event.target.getBoundingClientRect().top) < Math.abs(mouseY - event.target.getBoundingClientRect().bottom) ? row : row+1;
      let true_col = Math.abs(mouseX - event.target.getBoundingClientRect().left) < Math.abs(mouseX - event.target.getBoundingClientRect().right) ? col : col+1;
      var coordinates = true_row + " " + true_col;
      let moveEndpoint = "http://localhost:8080/move";
      let aiMoveEndpoint = "http://localhost:8080/move_ai";

      function createPiece(toPlay) {
        var target = event.target;
        var offset = findOffset(mouseX, mouseY, target.getBoundingClientRect().left, target.getBoundingClientRect().right, target.getBoundingClientRect().top, target.getBoundingClientRect().bottom, squareSize);
        var divAlreadyExists = document.querySelector('[data-coordinates="' + coordinates + '"]');
        var newDiv = document.createElement("div");
        // Apply styles to pieces
        newDiv.setAttribute("data-coordinates", coordinates);
        console.log(true_row + " " + true_col);
        newDiv.style.position = "absolute";
        newDiv.style.width = "20px";
        newDiv.style.height = "20px";
        newDiv.style.borderRadius = "50%";
        newDiv.style.overflow = "hidden";
        newDiv.style.left = target.getBoundingClientRect().left + offset[0] + "px";
        newDiv.style.top = target.getBoundingClientRect().top + offset[1] + "px";
        newDiv.style.background = toPlay;

        // Append the div to the document body
        document.body.appendChild(newDiv);
      }

      function createPieceAI(row, col) {
        let board_size = 500;

        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        let offset_row = ((screenWidth - board_size) / 2) + (col * squareSize) - 9;
        let offset_col = ((screenHeight - board_size) / 2) + (row * squareSize) + (2 * squareSize)- 9;

        var coordinates = row + " " + col;
        var divAlreadyExists = document.querySelector('[data-coordinates="' + coordinates + '"]');
        var newDiv = document.createElement("div");
        // Apply styles to pieces
        newDiv.setAttribute("data-coordinates", coordinates);
        console.log("AI COORDINATES: " + coordinates);
        newDiv.style.position = "absolute";
        newDiv.style.width = "20px";
        newDiv.style.height = "20px";
        newDiv.style.borderRadius = "50%";
        newDiv.style.overflow = "hidden";
        newDiv.style.left = offset_row + "px";
        newDiv.style.top = offset_col + "px";
        newDiv.style.background = "white";

        // Append the div to the document body
        document.body.appendChild(newDiv);
      }


      var alreadyExists = document.querySelector('[data-coordinates="' + coordinates + '"]');
      
      if(!alreadyExists) {
        let turnEndpoint = "http://localhost:8080/player_turn";
        getTurn(turnEndpoint)
        .then(turn => {
            makeMove(moveEndpoint, true_row, true_col);
            makeMoveAI(aiMoveEndpoint);
          });
      }
      

      function removePiece(coordinates) {
        var divToRemove = document.querySelector('[data-coordinates="' + coordinates + '"]');
        if (divToRemove) {
          divToRemove.remove();
        }
      }

      async function makeMove(moveEndpoint, true_row, true_col) {
        console.log("Made Move");
        const response = await fetch(moveEndpoint, {
          method: "POST", 
          cache: "no-cache",
          body: (true_row+1) + " " + (true_col+1), 
        });
        const removePieces = await response.json();
        console.log(removePieces);

        for (let i = 0; i < removePieces.length; i++) {
          let pair = removePieces[i];
          let firstElem = pair[0];
          let secondElem = pair[1];
          let to_remove = firstElem + " " + secondElem;
          removePiece(to_remove);
        }
      }

      async function getTurn(turnEndpoint) {
        const response = await fetch(turnEndpoint, {
          method: "GET", 
          cache: "no-cache",
        });
        const toPlay = await response.json();
        let playerTurn = (toPlay === "White") ? "white" : "black";
        createPiece(playerTurn);
        return playerTurn;
      }

      async function resetGame(resetEndpoint) {
        const response = await fetch(turnEndpoint, {
          method: "GET", 
          cache: "no-cache",
        });
        const reset = await response.json();
      }

      async function makeMoveAI(aiEndpoint) {
        const response = await fetch(aiEndpoint, {
          method: "GET", 
          cache: "no-cache",
        });
        const move = await response.json();
        const movesArray = move.split(" ");
        const true_row = parseInt(movesArray[0], 10);
        const true_col = parseInt(movesArray[1], 10);
        makeMove(moveEndpoint, true_row+1, true_col+1);
        createPieceAI(true_row+1, true_col+1);
      }
    });
                                        var boundingBox = partialFunCoordinates($$event, mouseX, mouseY, 26.203125, findOffset, row, col);
                                        console.log(boundingBox);
                                      };
                                      return JsxRuntime.jsx("div", {
                                                  className: "intersection",
                                                  onClick: handleClick
                                                }, String(Math.imul(row, cols) + col | 0));
                                    }));
                      }))));
}

let resetEndpoint = "http://localhost:8080/reset_game";

  window.addEventListener('unload', async function (event) {
      console.log("RESET!");
      try {
          await fetch(resetEndpoint, {method: 'GET',});
      } catch (error) {
          console.error("Error resetting the game:", error);
      }
  });
;

function App(props) {
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx("div", {
                    children: makeGrid(19, 19),
                    className: "go-board"
                  }),
              className: "container"
            });
}

var make = App;

export {
  make ,
}
/*  Not a pure module */
