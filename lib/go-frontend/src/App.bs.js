// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as JsxRuntime from "react/jsx-runtime";

import './App.css'
;

function findOffset(x, y, left, right, top, bottom, squareSize) {
  if (x >= (left - 1 | 0) && x <= ((right + 1 | 0) - (squareSize / 2 | 0) | 0) && y >= (top - 1 | 0) && y <= ((bottom + 1 | 0) - (squareSize / 2 | 0) | 0)) {
    return [
            -10.0,
            -10.0
          ];
  } else if (x >= (left - 1 | 0) && x <= ((right + 1 | 0) - (squareSize / 2 | 0) | 0) && y >= ((top - 1 | 0) + (squareSize / 2 | 0) | 0) && y <= (bottom + 1 | 0)) {
    return [
            -10.0,
            15.5
          ];
  } else if (x >= ((left - 1 | 0) + (squareSize / 2 | 0) | 0) && x <= (right + 1 | 0) && y >= (top - 1 | 0) && y <= ((bottom + 1 | 0) - (squareSize / 2 | 0) | 0)) {
    return [
            15.5,
            -10.0
          ];
  } else if (x >= ((left - 1 | 0) + (squareSize / 2 | 0) | 0) && x <= (right + 1 | 0) && y >= ((top - 1 | 0) + (squareSize / 2 | 0) | 0) && y <= (bottom + 1 | 0)) {
    return [
            15.5,
            15.5
          ];
  } else {
    return [0.0];
  }
}

function makeGrid(rows, cols) {
  var rowArray = Belt_List.makeBy(rows, (function (i) {
          return i;
        }));
  var colArray = Belt_List.makeBy(cols, (function (i) {
          return i;
        }));
  return Belt_List.toArray(Belt_List.flatten(Belt_List.map(rowArray, (function (row) {
                        return Belt_List.map(colArray, (function (col) {
                                      var handleClick = function ($$event) {
                                        var mouseX = $$event.clientX;
                                        var mouseY = $$event.clientY;
                                        var partialFunCoordinates = (function(event, mouseX, mouseY, squareSize, findOffset, row, col) {
      let true_row = Math.abs(mouseY - event.target.getBoundingClientRect().top) < Math.abs(mouseY - event.target.getBoundingClientRect().bottom) ? row : row+1;
      let true_col = Math.abs(mouseX - event.target.getBoundingClientRect().left) < Math.abs(mouseX - event.target.getBoundingClientRect().right) ? col : col+1;

      function createPiece(toPlay) {
        var target = event.target;
        var offset = findOffset(mouseX, mouseY, target.getBoundingClientRect().left, target.getBoundingClientRect().right, target.getBoundingClientRect().top, target.getBoundingClientRect().bottom, squareSize);
        var newDiv = document.createElement("div");
        // Apply styles to pieces
        newDiv.setAttribute("data-coordinates", true_row + " " + true_col);
        console.log(true_row + " " + true_col);
        newDiv.style.position = "absolute";
        newDiv.style.width = "20px";
        newDiv.style.height = "20px";
        newDiv.style.borderRadius = "50%";
        newDiv.style.overflow = "hidden";
        newDiv.style.left = target.getBoundingClientRect().left + offset[0] + "px";
        newDiv.style.top = target.getBoundingClientRect().top + offset[1] + "px";
        newDiv.style.background = toPlay;

        // Append the div to the document body
        document.body.appendChild(newDiv);

        return [target.getBoundingClientRect().left, target.getBoundingClientRect().right , target.getBoundingClientRect().bottom , target.getBoundingClientRect().top ];
      }

      let turnEndpoint = "http://localhost:8080/player_turn";
      getTurn(turnEndpoint)
      .then(_ => {
          let moveEndpoint = "http://localhost:8080/move";
          return makeMove(moveEndpoint);
        });

      function removePiece(coordinates) {
        var divToRemove = document.querySelector('[data-coordinates="' + coordinates + '"]');
        if (divToRemove) {
          divToRemove.remove();
        }
        divToRemove = document.querySelector('[data-coordinates="' + coordinates + '"]');
        if (divToRemove) {
          divToRemove.remove();
        }
      }
      async function makeMove(moveEndpoint) {
        console.log("Made Move");
        const response = await fetch(moveEndpoint, {
          method: "POST", 
          cache: "no-cache",
          body: (true_row+1) + " " + (true_col+1), 
        });
        const removePieces = await response.json();
        console.log(removePieces);

        for (let i = 0; i < removePieces.length; i++) {
          let pair = removePieces[i];
          let firstElem = pair[0];
          let secondElem = pair[1];
          let to_remove = firstElem + " " + secondElem;
          console.log(to_remove);
          removePiece(to_remove);
        }
      }

      async function getTurn(apiUrl) {
        const response = await fetch(apiUrl, {
          method: "GET", 
          cache: "no-cache",
        });
        const toPlay = await response.json();
        if(toPlay === "White") {
          createPiece("white");
        } else {
          createPiece("black");
        }
        console.log(toPlay);
      }
    });
                                        var boundingBox = partialFunCoordinates($$event, mouseX, mouseY, 26.203125, findOffset, row, col);
                                        console.log(boundingBox);
                                      };
                                      return JsxRuntime.jsx("div", {
                                                  className: "intersection",
                                                  onClick: handleClick
                                                }, String(Math.imul(row, cols) + col | 0));
                                    }));
                      }))));
}

function App(props) {
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx("div", {
                    children: makeGrid(19, 19),
                    className: "go-board"
                  }),
              className: "container"
            });
}

var make = App;

export {
  make ,
}
/*  Not a pure module */
